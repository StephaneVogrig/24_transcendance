Arrays & Structs:
uses push to add to array
struct can use Struct(params) to instantiate

Maps:
mapping have "infinite" size, need a hardcoded count variable to keep its size
mapping(key => value) visibility name;
name[key] = value;

Keywords:
external = only outside the contract
internal = private
indexed = able to listen to specific (address) (?)
payable (in function) = accepts ether (can use msg.value to know how much was sent)
payable (in address) = wallet that can accept ether within a smart contract
require = if keyword that throws error if condition not met (require(a > b))
immutable = won't change after being set in constructor (like const but can instantiate after declaring)
memory = malloc
calldata = consumes less than memory for function calls

modifier:
set after all keywords in a function. gives a requirement in order to call the function. i.e.: onlyOwner (inside modifier: require(msg.sender == owner (owner being a variable), "errorMsg");) = only the owner of the contract can call function
add _; at the end of the modifier to say "continue the function"

"fallback" function:
default function called ?
using external ?
function() external {} (no function name)

events:
event name(params)
emit name(params)
broadcasts the event in the blockchain. js can then "subscribe" to the event to wait for the emit keyword (?)

on multiple contracts:
calling another contract's function that has msg.sender will take the calling contract's address, not the user's address. use tx.origin instead

in inheritance:
super keyword to call inherited functions (i.e.: function getName() in parent, use super.getName() in child)

library:
library name { function internal }

multiple files:
import "./file.sol";

use library on types:
using libraryName for type; (using Math for uint256)
now each uint256 can directly call the library's functions (i.e.: uint256 a = 5; uint256 b = a.divide(5);)